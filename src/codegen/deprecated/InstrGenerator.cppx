#include "InstrGenerator.hpp"

#define UPDATE_NONCONSTANT_REGION_BEGIN				\
	bool oldFlagValue = _isNonConstantLoopRegion;	\
	if (!forStatement->isConstant())				\
	_isNonConstantLoopRegion = true;

#define UPDATE_NONCONSTANT_REGION_END				\
	_isNonConstantLoopRegion = oldFlagValue;

namespace vesyla{
namespace codegen{

// This method creates a Jump instruction and adds it to the corresponding DRRA cell and also to the instruction map.
JumpInstruction* InstrGenerator::createJumpInstruction(int statementNo_, VIR::Coordinate& coord_, LoopValuesMap * loopValues_)
{
	JumpInstruction * jumpInst = CREATE_OBJECT_B(JumpInstruction);

	const Coordinate & dpuCoord = coord_;

	jumpInst->statementNo = statementNo_;
	jumpInst->unrolledStatementNo = getUnrolledStatementSignature2(statementNo_, loopValues_, dpuCoord);
	jumpInst->jumpAddressInstruction = 0; // It should be filled later

	_branchManager.jumpInst = jumpInst; // It is saved in order to fill the jump address

	_drraCluster->getDRRACell(dpuCoord)->instructions().addInstruction(jumpInst, true);

	addInstructionToMap(jumpInst, statementNo_, loopValues_, dpuCoord, dpuCoord);
	return jumpInst;
}

// This method creates some LOOP_HEADER instructions and adds them to all DRRA cells corresponding to the given for-statement.
map<string, BIR::LoopHeaderInstruction*> InstrGenerator::createLoopHeaderInstruction(ForStatement * forStatement_, LoopValuesMap * loopValues_, json& j_, string path_)
{
	map<string, BIR::LoopHeaderInstruction*> loop_header_instr_map;
	int loopId = -1;

	LoopHeaderInstruction * loopHeaderInst;

	const int statementNo = forStatement_->statementNo();

	int iterationNo;
	bool isIterationStatic = true;
	int offsetForDynamicBound = 0;
	ForStatement * dependentForStatement = 0;
	bool hasRaccuVariable = false;

	if (forStatement_->isConstant())
		iterationNo = forStatement_->repetition();
	else
	{
		RangeExpression * loopBound = forStatement_->loopRange();
		BinaryExpression * binaryExpr = (BinaryExpression *) loopBound->end();

		hasRaccuVariable = loopBound->end()->kind() == ktIdentifier && ((Identifier *)loopBound->end())->object()->objectType() == otRaccuVariable;

		// Currently dynamic loops are only supported with the following condition:
		//  - Start of the loop bound and the step value should be constant.
		//  - End of the loop bound can be dependent to only one other loop iteration or a RACCU variable.
		//  - The expression of the loop bound end value can be in three formats: 
		//    'r', 'i', and 'i+c', where 'r' is a RACCU variable, 'i' is the loop variable of another loop and 'c' is a constant number.
		if (!(loopBound->begin()->kind() == ktInteger && loopBound->increment()->kind() == ktInteger && 
			 (hasRaccuVariable || 
			 (loopBound->end()->kind() == ktIdentifier && ((Identifier *)loopBound->end())->object()->isLoopIndex()) || 
			 (loopBound->end()->kind() == ktBinaryExpression && binaryExpr->operatorType() == botAdd && 
			  ((binaryExpr->leftOperand()->kind() == ktIdentifier && ((Identifier *)binaryExpr->leftOperand())->object()->isLoopIndex() &&
			    binaryExpr->rightOperand()->kind() == ktInteger) || binaryExpr->leftOperand()->kind() == ktInteger) &&
			  ((binaryExpr->rightOperand()->kind() == ktIdentifier && ((Identifier *)binaryExpr->rightOperand())->object()->isLoopIndex() &&
			    binaryExpr->leftOperand()->kind() == ktInteger) || binaryExpr->rightOperand()->kind() == ktInteger)))))
			LOG(FATAL) << ("createLoopHeaderInstruction: Unsupported variable loop boundaries!");

		Identifier * indexIdentifier = 0;

		// Find the identifier (referring to the index of another for-statement) inside the dynamic bound.
		if (loopBound->end()->kind() == ktIdentifier)
			indexIdentifier = (Identifier *)loopBound->end();
		else if (loopBound->end()->kind() == ktBinaryExpression)
		{
			indexIdentifier = binaryExpr->leftOperand()->kind() == ktIdentifier ? 
				(Identifier *)binaryExpr->leftOperand() : (Identifier *)binaryExpr->rightOperand();

			offsetForDynamicBound = binaryExpr->leftOperand()->kind() == ktInteger ? 
				((Integer *)binaryExpr->leftOperand())->value : ((Integer *)binaryExpr->rightOperand())->value;
		}

		// The corresponding for-statement for the indexIdentifier.
		dependentForStatement = ((LoopObjectDeclaration *) indexIdentifier->object())->forStatement();

		isIterationStatic = false;
	}

	Integer * startValue = dynamic_cast<Integer *> (forStatement_->loopRange()->begin());
	if (!startValue)
		LOG(FATAL) << ("createLoopHeaderInstruction: Unsupported data type in the loop range!");

	int id_counter=0;
	int first_header_id = -1;
	for (auto const &element : _allUtilizedCells)
	{
		Coordinate coordinate = element.second;

		DRRACell * drraCell = _drraCluster->getDRRACell(coordinate);

		string unrolledStatementNo = getUnrolledStatementSignature2(statementNo, loopValues_, coordinate);

		loopId = drraCell->sequencer()->raccu()->getFreeLoopId();

		if (loopId == -1)
			LOG(FATAL) << ("createLoopHeaderInstruction: Reached the maximum number of supported RACCU loops!");

		int raccu_instr_count_1 = drraCell->instructions().size();
		// If dynamic loop bound has a corresponding RACCU variable
		if (hasRaccuVariable){
			iterationNo = _raccuVariablesAddressMap[getRaccuVariableSignature(((Identifier *)forStatement_->loopRange()->end())->object()->name(), coordinate)];
		}
		// For dynamic loop bounds without a RACCU variable, a RACCU instruction should be added before the LOOP_HEADER instruction
		else if (!isIterationStatic)
		{
			int resultAddress = -3;

			int dependentLoopId = _loopHeaderInstructionMap[getLoopSignature(dependentForStatement, coordinate, true)]->loopId;

			createRaccuInstruction(statementNo, rmAddWithLoopIndex, dependentLoopId, true, offsetForDynamicBound, true, resultAddress, coordinate, coordinate, loopValues_, 0);

			iterationNo = resultAddress;
		}
		int raccu_instr_count_2 = drraCell->instructions().size();

		loopHeaderInst = CREATE_LOOP_HEADER_INST(statementNo, unrolledStatementNo, loopId, isIterationStatic, startValue->value, iterationNo);
		loop_header_instr_map[to_string(coordinate.row)+"_"+to_string(coordinate.column)] = (loopHeaderInst);

		drraCell->instructions().addInstruction(loopHeaderInst, true);

		addInstructionToMap(loopHeaderInst, statementNo, loopValues_, coordinate, coordinate);

		// Add the loop instruction to the loop map.
		_loopHeaderInstructionMap[getLoopSignature(forStatement_, coordinate, true)] = loopHeaderInst;

		// Set the upper loop instruction
		ForStatement * upperLoop = getUpperLoop(dynamic_cast<ControlStatement*>(forStatement_->controlDependentTo()));

		if (upperLoop && _loopHeaderInstructionMap.find(getLoopSignature(upperLoop, coordinate, true)) != _loopHeaderInstructionMap.end())
		{
			loopHeaderInst->upperLoop = _loopHeaderInstructionMap[getLoopSignature(upperLoop, coordinate, true)];
			loopHeaderInst->upperLoop->innerLoops.push_back(loopHeaderInst);
		}

		json j_loop_header;
		j_loop_header["id"] = id_counter;
		if(first_header_id<0){
			first_header_id = id_counter;
		}
		j_loop_header["name"] = path_+to_string(id_counter);
		loopHeaderInst->labels.push_back(path_+to_string(id_counter));
		j_loop_header["resource"][to_string(coordinate.row)+"_"+to_string(coordinate.column)+"_SEQ"].push_back(0);
		j_loop_header["resource"][to_string(coordinate.row)+"_"+to_string(coordinate.column)+"_SEQ"].push_back(0);
		j_loop_header["node_type"] = 2;
		j_["vertex"].push_back(j_loop_header);
		if(first_header_id != j_loop_header["id"]){
			json j_loop_edge;
			j_loop_edge["src_id"] = first_header_id;
			j_loop_edge["dest_id"] = j_loop_header["id"];
			j_loop_edge["link_type"] = 1;
			j_loop_edge["distance"] = 0;
			j_["edge"].push_back(j_loop_edge);
		}
		id_counter++;

		int last_raccu_id = -1;
		for(int i=raccu_instr_count_1; i<raccu_instr_count_2; i++){
			json j_loop_raccu;
			j_loop_raccu["id"] = id_counter;
			j_loop_raccu["name"] = path_ + to_string(id_counter);
			drraCell->instructions().instruction(i)->labels.push_back(path_ + to_string(id_counter));
			j_loop_raccu["resource"][to_string(coordinate.row)+"_"+to_string(coordinate.column)+"_SEQ"].push_back(0);
			j_loop_raccu["resource"][to_string(coordinate.row)+"_"+to_string(coordinate.column)+"_SEQ"].push_back(0);
			j_loop_raccu["node_type"] = 2;
			j_["vertex"].push_back(j_loop_raccu);
			if(last_raccu_id>=0){
				json edge;
				edge["src_id"] = last_raccu_id;
				edge["dest_id"] = j_loop_raccu["id"];
				edge["link_type"]= 0;
				edge["distance"] = 0;
				j_["edge"].push_back(edge);
			}
			last_raccu_id = id_counter;
			id_counter++;
		}

		if(last_raccu_id>=0){
			json edge;
			edge["src_id"]=last_raccu_id;
			edge["dest_id"] = j_loop_header["id"];
			edge["link_type"] = 0;
			edge["distance"] = 0;
			j_["edge"].push_back(edge);
		}
	}

	_numberOfRaccuLoops++;

	return loop_header_instr_map;
}

// This method creates some LOOP_TAIL instructions and adds them to all DRRA cells corresponding to the given for-statement.
void InstrGenerator::createLoopTailInstruction(ForStatement * forStatement_, LoopValuesMap * loopValues_, json& j_, string path_)
{
	LoopTailInstruction * loopTailInst;

	const int statementNo = forStatement_->statementNo();

	Integer * stepValue = dynamic_cast<Integer *> (forStatement_->loopRange()->increment());
	if (!stepValue)
		LOG(FATAL) << ("createLoopTailInstruction: Unsupported data type in the loop range!");

	// This will be filled later in the synchronization part
	const int gotoPC = 0;

	int id_counter = 0;
	int first_loop_tail_id = -1;
	for (auto const &element : _allUtilizedCells)
	{
		Coordinate coordinate = element.second;

		string unrolledStatementNo = getUnrolledStatementSignature2(statementNo, loopValues_, coordinate);

		// Get the corresponding loop header instruction
		LoopHeaderInstruction * loopHeaderInst = _loopHeaderInstructionMap[getLoopSignature(forStatement_, coordinate, true)];

		loopTailInst = CREATE_LOOP_TAIL_INST(statementNo, unrolledStatementNo, loopHeaderInst->loopId, gotoPC, stepValue->value);

		loopHeaderInst->correspondingLoopTailInst = loopTailInst;

		const string loopTailSignature = getLoopSignature(forStatement_, coordinate, false);

		vector<MappedRaccuInstruction>::iterator iter = _deferredRaccuInstructions.begin();

		// Before adding the LOOP_TAIL instruction to the DRRA cell, add all postponed RACCU 
		// instructions corresponding to this loop tail and erase them from the list.
		int raccu_instr_count_1 = _drraCluster->getDRRACell(coordinate)->instructions().size();
		while (iter != _deferredRaccuInstructions.end())
		{
			if (loopTailSignature == iter->loopTailSignature)
			{
				_drraCluster->getDRRACell(coordinate)->instructions().addInstruction(iter->raccuInst, true);
				iter = _deferredRaccuInstructions.erase(iter);
			}
			else
				iter++;
		}
		int raccu_instr_count_2 = _drraCluster->getDRRACell(coordinate)->instructions().size();
		_drraCluster->getDRRACell(coordinate)->instructions().addInstruction(loopTailInst, true);

		addInstructionToMap(loopTailInst, statementNo, loopValues_, coordinate, coordinate);

		// create json dependency graph
		json j_loop_tail;
		j_loop_tail["id"] = id_counter;
		j_loop_tail["name"] = path_+to_string(id_counter);
		loopTailInst->labels.push_back(path_+to_string(id_counter));
		j_loop_tail["resource"][to_string(coordinate.row)+"_"+to_string(coordinate.column)+"_SEQ"].push_back(0);
		j_loop_tail["resource"][to_string(coordinate.row)+"_"+to_string(coordinate.column)+"_SEQ"].push_back(0);
		j_loop_tail["node_type"] = 2;
		j_["vertex"].push_back(j_loop_tail);
		id_counter++;

		if(first_loop_tail_id<0){
			first_loop_tail_id = j_loop_tail["id"];
		}

		int last_raccu_id = -1;
		for(int i=raccu_instr_count_1; i<raccu_instr_count_2; i++){
			json j_loop_raccu;
			j_loop_raccu["id"] = id_counter;
			j_loop_raccu["name"] = path_ + to_string(id_counter);
			_drraCluster->getDRRACell(coordinate)->instructions().instruction(i)->labels.push_back(path_ + to_string(id_counter));
			j_loop_raccu["resource"][to_string(coordinate.row)+"_"+to_string(coordinate.column)+"_SEQ"].push_back(0);
			j_loop_raccu["resource"][to_string(coordinate.row)+"_"+to_string(coordinate.column)+"_SEQ"].push_back(0);
			j_loop_raccu["node_type"] = 2;
			j_["vertex"].push_back(j_loop_raccu);
			if(last_raccu_id>=0){
				json edge;
				edge["src_id"] = last_raccu_id;
				edge["dest_id"] = j_loop_raccu["id"];
				edge["link_type"]= 0;
				edge["distance"] = 0;
				j_["edge"].push_back(edge);
			}
			last_raccu_id = id_counter;
			id_counter++;
		}

		if(last_raccu_id>=0){
			json edge;
			edge["src_id"] = last_raccu_id;
			edge["dest_id"] = j_loop_tail["id"];
			edge["link_type"] = 0;
			edge["distance"] = 0;
			j_["edge"].push_back(edge);
		}

		if(first_loop_tail_id != j_loop_tail["id"]){
			json edge;
			edge["src_id"] = first_loop_tail_id;
			edge["dest_id"] = j_loop_tail["id"];
			edge["link_type"] = 1;
			edge["distance"] = 0;
			j_["edge"].push_back(edge);
		}
	}
}

// This method creates a DPU instruction and adds it to the corresponding DRRA cell and also to the instruction map.
// The DPU instruction object is passed as the first argument to the method instead of creating it inside.
// It is because we need to fill the correspondingSWBInst before setting all other fields.
void InstrGenerator::createDpuInstruction(BIR::DPUInstruction * dpuInst_, int statementNo_, string unrolledStatementNo_, VIR::DPUPragma * dpuPragma_,
								   LoopValuesMap * loopValues_, const Coordinate & dpuCoord_, int repetition_, bool fixedPointMode_)
{
	dpuInst_->statementNo = statementNo_;
	dpuInst_->mode = dpuPragma_->dpuMode;
	dpuInst_->saturation = dpuPragma_->saturation;
	dpuInst_->modeValue = getDpuModeValue(dpuInst_->mode);
	dpuInst_->executionCycle = getDpuModeExecCycle(dpuInst_->mode);
	if(dpuInst_->executionCycle <0){
		dpuInst_->executionCycle=repetition_+1;
	}
	dpuInst_->unrolledStatementNo = unrolledStatementNo_;
	dpuInst_->repetition = repetition_;
	dpuInst_->ioChange = dpuInst_->mode != "__sl_dpu_abs_sub_acc" ? dicUnchanged : dicAbsoluteOfOutput;
	dpuInst_->constantValue = 0;
	dpuInst_->fixedPointMode = fixedPointMode_;

	_drraCluster->getDRRACell(dpuCoord_)->instructions().addInstruction(dpuInst_, true);
	_drraCluster->getDRRACell(dpuCoord_)->dpuInstructions().addInstruction(dpuInst_, false);

	addInstructionToMap(dpuInst_, statementNo_, loopValues_, dpuCoord_, dpuCoord_);
}

// This method creates a dummy wait instruction for referencing as the jump address or 
// false address in special cases of branching (see the note on top of the file).
// The return value is the created dummy instruction.
BIR::WaitInstruction * InstrGenerator::createDummyWaitInstruction(int statementNo_, LoopValuesMap * loopValues_, VIR::Coordinate & coord_)
{
	const Coordinate & dpuCoord = coord_;

	// Create a dummy wait instruction
	WaitInstruction * dummyWaitInst = CREATE_WAIT_INST(statementNo_, getUnrolledStatementSignature2(statementNo_, loopValues_, dpuCoord), 1, true, 0);

	DRRACell * drraCell = _drraCluster->getDRRACell(dpuCoord);
	drraCell->instructions().addInstruction(dummyWaitInst, true);

	return dummyWaitInst;
}


// This method creates a BRANCH instruction and adds it to the corresponding DRRA cell and also to the instruction map.
// 1st argument (binaryExpression) is the condition of the if statement. Currently this condition can only be a binary expression.
BranchInstruction* InstrGenerator::createBranchInstruction(VIR::BinaryExpression * binaryExpression, int statementNo_, string unrolledStatementNo_, const VIR::Coordinate & coord_, LoopValuesMap * loopValues_)
{
	BranchMode branchMode;
	int modeValue;

	switch (binaryExpression->operatorType())
	{
		case botGreaterThan:	branchMode = bmGreater;			modeValue = 1; break;
		case botGreaterOrEqual: branchMode = bmGreaterOrEqual;	modeValue = 3; break;
		case botEqual:			branchMode = bmEqual;			modeValue = 2; break;

		// These cases should have already been converted to the above types in the elaboration phase.
		case botLessThan:
		case botLessOrEqual:
		case botUnEqual:
			LOG(FATAL) << ("createBranchInstruction: (Internal Error) Should have already been converted to another operator!");
		break;

		default:
			LOG(FATAL) << ("createBranchInstruction: Unsupported conditional operator!");
	}

	BranchInstruction * branchInst = CREATE_OBJECT_B(BranchInstruction);

	branchInst->statementNo = statementNo_;
	branchInst->unrolledStatementNo = unrolledStatementNo_;
	branchInst->falseAddressInstruction = 0; // should be filled later
	branchInst->mode = branchMode;
	branchInst->modeValue = modeValue;

	_branchManager.branchInst = branchInst; // It is saved in order to fill the falseAddress

	const Coordinate & dpuCoord = coord_;

	_drraCluster->getDRRACell(dpuCoord)->instructions().addInstruction(branchInst, true);

	addInstructionToMap(branchInst, statementNo_, loopValues_, dpuCoord, dpuCoord);
	return branchInst;
}

// This method creates a memory route instruction and adds it to the corresponding DiMArch cell and also to the instruction map.
BIR::RouteInstruction * InstrGenerator::createRouteInstruction(int statementNo_, string unrolledStatementNo_, const VIR::Coordinate & memoryCoord_, 
									 const VIR::Coordinate & regFileCoord_, LoopValuesMap * loopValues_, bool isMemToRegTrans_, const string variableName_)
{
	DRRACell * drraCell = _drraCluster->getDRRACell(regFileCoord_);

	RouteInstruction * routeInst = CREATE_OBJECT_B(RouteInstruction);

	routeInst->variableName			= variableName_;
	routeInst->statementNo			= statementNo_;
	routeInst->unrolledStatementNo	= unrolledStatementNo_;
	routeInst->drraSelect			= regFileCoord_.row;
	routeInst->isFromSource			= isMemToRegTrans_;

	const int memoryActualRow = getActualDimarchRow(memoryCoord_.row);

	if (isMemToRegTrans_)
	{
		routeInst->sourceCoordinate = Coordinate(memoryActualRow, memoryCoord_.column);
		routeInst->destCoordinate   = Coordinate(0, regFileCoord_.column);
	}
	else
	{
		routeInst->sourceCoordinate = Coordinate(0, regFileCoord_.column);
		routeInst->destCoordinate   = Coordinate(memoryActualRow, memoryCoord_.column);
	}

	drraCell->instructions().addInstruction(routeInst, true);

	addInstructionToMap(routeInst, statementNo_, loopValues_, regFileCoord_, regFileCoord_);

	return routeInst;
}

// This method creates a memory SRAM instruction and adds it to the corresponding DiMArch cell and also to the instruction map.
SRAMInstruction * InstrGenerator::createSramInstruction(VIR::SliceName * sliceName_, int statementNo_, string unrolledStatementNo_,const VIR::Coordinate & memoryCoord_,
									const VIR::Coordinate & regFileCoord_, LoopValuesMap * loopValues_, bool isMemToRegTrans_, IndexInfo * indexInfo_,
									int memoryStartAddr_, const string variableName_, BIR::RefiInstruction * correspondingRefiInst_, BIR::RouteInstruction * correspondingRouteInst_)
{
	DRRACell * drraCell = _drraCluster->getDRRACell(regFileCoord_);

	_drraCluster->hasMemoryInstructions(true);

	SRAMInstruction * sramInst = CREATE_OBJECT_B(SRAMInstruction);

	sramInst->variableName			 = variableName_;
	sramInst->statementNo		     = statementNo_;
	sramInst->unrolledStatementNo    = unrolledStatementNo_;
	sramInst->isRead				 = isMemToRegTrans_;
	sramInst->correspondingRefiInst  = correspondingRefiInst_;
	sramInst->correspondingRouteInst = correspondingRouteInst_;
	sramInst->initialDelay(0, true);
	sramInst->loop1Delay(0, true);
	sramInst->loop2Delay(0, true);

	const AddressInfo & addressInfo = indexInfo_->addressInfo;

	sramInst->loop1Increment = addressInfo.increment;


	bool isStartAddressDynamic = false;
	
	// numberOfAddress is one less than the total number of addresses
	const int totalAddressesNum = addressInfo.numberOfAddress + 1;

	// Subtracting 1 from the start address is because MATLAB indices are started from 1, however Memory indexing is started from 0.
	int startAddress = addressInfo.startAddress - 1;

	int memStartAddress = 0;

	RangeExpression * rangeExpression = dynamic_cast<RangeExpression *> (sliceName_->suffix()[0]);

	if (!rangeExpression)
		LOG(FATAL) << ("createSramInstruction: Improper range address for memory transfer!");

	if (totalAddressesNum % cMemWordSplit != 0)
		LOG(FATAL) << ("createSramInstruction: For memory transfer, variable slice should be a multiple of 16!");

	if (!_raccuMode && !_isNonConstantLoopRegion)
	{
		if (startAddress % cMemWordSplit != 0)
			LOG(FATAL) << ("createSramInstruction: For memory transfer, variable slice should be a multiple of 16!");

		memStartAddress = startAddress / cMemWordSplit + memoryStartAddr_;

		for (auto& element: indexInfo_->unrollingMap())
			memStartAddress += (element.second->unrollingOffset / cMemWordSplit) * loopValues_->at(element.first);

	}
	// Dynamic calculations
	else if (!_isNonConstantLoopRegion)
	{
		memStartAddress = startAddress;

		const string indexVariableName = rangeExpression->begin()->kind() == ktIdentifier ? ((Identifier *)rangeExpression->begin())->name() : "";

		isStartAddressDynamic = calculateDynamicStartAddress(memStartAddress, indexInfo_, statementNo_, sramInst, loopValues_, regFileCoord_, 
															 regFileCoord_, indexVariableName, true);
	}
	else
		LOG(FATAL) << ("createSramInstruction: Unsupported memory transfer!");

	sramInst->initialAddress(memStartAddress, !isStartAddressDynamic);
	sramInst->loop1Iterations(totalAddressesNum / cMemWordSplit - 1, true);
	sramInst->loop2Increment = 0;
	sramInst->loop2Iterations(0, true);

	drraCell->instructions().addInstruction(sramInst, true);

	addInstructionToMap(sramInst, statementNo_, loopValues_, regFileCoord_, regFileCoord_);

	return sramInst;
}

// This method creates a SWB instruction for a variable.
BIR::SWBInstruction * InstrGenerator::createSwbInstruction(int statementNo_, string unrolledStatementNo_, const string & variableName_,
													LoopValuesMap * loopValues_, vector<BIR::SWBInstruction *> & swbInstructions_,
													const VIR::Coordinate & referenceCoord_, const BIR::ComponentInfo & srcComponentInfo_,
													const BIR::ComponentInfo & destComponentInfo_)
{
	SWBInstruction * swbInst;
	swbInst = _swb_manager.check_connection(
			_swb_manager.get_signature(
					srcComponentInfo_.cellCoordinate.row,
					srcComponentInfo_.cellCoordinate.column,
					(int)(srcComponentInfo_.type),
					srcComponentInfo_.portNo
			),
			_swb_manager.get_signature(
					destComponentInfo_.cellCoordinate.row,
					destComponentInfo_.cellCoordinate.column,
					(int)(destComponentInfo_.type),
					destComponentInfo_.portNo
			)
	);
	if(swbInst){
		return swbInst;
	}

	swbInst = CREATE_OBJECT_B(SWBInstruction);
	swbInstructions_.push_back(swbInst);

	swbInst->statementNo = statementNo_;
	swbInst->variableName = variableName_;
	swbInst->unrolledStatementNo = unrolledStatementNo_;

	swbInst->source = srcComponentInfo_;
	swbInst->destination = destComponentInfo_;

	InstructionList & instructionList = _drraCluster->getDRRACell(destComponentInfo_.cellCoordinate)->instructions();

	swbInst->dependentTo = 0;

	// If this switch box is related to an output variable
	if (swbInst->destination.type == ctRegFile)
	{
		bool ignoreRegion = false;

		// Perform a linear backward search to find a SWB instruction with the same destination and port number (if exists) in order to
		// set it as a dependent SWB instruction. It is used later for calculating the minimum scheduled cycle of the new SWB instruction.
		// A special case is else-part of a branch that should not be falsely bind to a SWB instruction in the then-part.
		for (int instIndex = instructionList.size() - 1; instIndex >= 0; --instIndex)
		{
			Instruction * instruction = instructionList.instruction(instIndex);

			// If the new SWB instruction is in the else-part region, we should ignore dependencies to SWB instructions in the then-part region.
			if (_branchManager.isElsePartRegion)
			{
				// As the loop iteration is backward, When it reaches a jump instruction, it means that we are entering the then-part region.
				if (instruction->kind() == bktJumpInstruction)
					ignoreRegion = true;
				// When it reaches a branch instruction, it means that we are exiting the then-part region.
				else if (instruction->kind() == bktBranchInstruction)
					ignoreRegion = false;
			}

			SWBInstruction * prevSWBInst = dynamic_cast<SWBInstruction *> (instruction);

			if (!ignoreRegion && prevSWBInst && prevSWBInst->destination.type == ctRegFile && prevSWBInst->destination.portNo == swbInst->destination.portNo)
			{
				swbInst->dependentTo = prevSWBInst;
				break;
			}
		}
	}

	if (!_isResourceSharingRegion)
	{
		swbInst->isInResSharingRegion = false;
		instructionList.addInstruction(swbInst, true);
	}
	else
	{
		swbInst->isInResSharingRegion = true;
		_resSharingInstructionManager.addInstruction(swbInst, destComponentInfo_.cellCoordinate);
	}

	addInstructionToMap(swbInst, statementNo_, loopValues_, referenceCoord_, destComponentInfo_.cellCoordinate);


	_swb_manager.update_connection(
			_swb_manager.get_signature(
					srcComponentInfo_.cellCoordinate.row,
					srcComponentInfo_.cellCoordinate.column,
					(int)(srcComponentInfo_.type),
					srcComponentInfo_.portNo
			),
			_swb_manager.get_signature(
					destComponentInfo_.cellCoordinate.row,
					destComponentInfo_.cellCoordinate.column,
					(int)(destComponentInfo_.type),
					destComponentInfo_.portNo
			),
			swbInst
		);

	return swbInst;
}

// This method creates a RACCU instruction.
// Operands:
//  - If an operand is dynamic and the operand value is -1, it means that a free location of the RACCU register file should be allocated to that operand.
// Result Address:
//  - If resultAddress_ is -1, it means that operand1_ is dynamic and result address should get the location of operand1_.
//  - If resultAddress_ is -2, it means that operand2_ is dynamic and result address should get the location of operand2_.
//  - If resultAddress_ is -3, it means that a free location of the RACCU register file should be allocated to the result address.
//  - For positive values of resultAddress_, result address will directly get that value.
//  - The resultAddress will be updated with the correct address if it has had an undetermined location (-1, -2, -3).
// The dependentRefiInst_ argument is the corresponding REFI instruction and it is used for RACCU instruction scheduling.
// The instInsertLocation_ argument determines the location that the RACCU instruction should be inserted to the corresponding instruction list.
//  - By default it is -1 which means that add the instruction to the end of the list.
//  - If the value is -2, it means that the RACCU instruction should be added to the _deferredRaccuInstructions list for a postponed insertion.
// The last argument (forStatement_) is used only when instInsertLocation_ == -2 and it helps in creating a signature for the location of inserting the RACCU instruction.
void InstrGenerator::createRaccuInstruction(int statementNo_, BIR::BIREnumerations::RACCUMode raccuMode_, int operand1_, bool isOp1Static_, int operand2_, bool isOp2Static_, 
									 int & resultAddress_, const VIR::Coordinate & cellCoord_, const VIR::Coordinate & refCoord_, LoopValuesMap * loopValues_,
									 BIR::Instruction * dependentInst_, int instInsertLocation_ /* = -1 */, VIR::ForStatement * forStatement_ /* = 0 */)
{
	RACCUInstruction * raccuInst = CREATE_OBJECT_B(RACCUInstruction);

	int raccuFreeAddress;

	raccuInst->statementNo = statementNo_;
	raccuInst->unrolledStatementNo = getUnrolledStatementSignature2(statementNo_, loopValues_, cellCoord_);
	raccuInst->raccuMode = raccuMode_;
	raccuInst->dependentTo = dependentInst_;

	if (isOp1Static_ || operand1_ != -1)
		raccuInst->operand1(operand1_, isOp1Static_);
	else
	{
		ALLOCATE_RACCU_ADDRESS;

		raccuInst->operand1(raccuFreeAddress, false);
	}

	if (isOp2Static_ || operand2_ != -1)
		raccuInst->operand2(operand2_, isOp2Static_);
	else
	{
		ALLOCATE_RACCU_ADDRESS;

		raccuInst->operand2(raccuFreeAddress, false);
	}

	switch (resultAddress_)
	{
		case -1: raccuInst->resultAddress = raccuInst->operand1.value; break;
		case -2: raccuInst->resultAddress = raccuInst->operand2.value; break;
		case -3: ALLOCATE_RACCU_ADDRESS;
	 			 raccuInst->resultAddress = raccuFreeAddress;		   break;
		default: raccuInst->resultAddress = resultAddress_;			   break;
	}

	// Updating the result address
	resultAddress_ = raccuInst->resultAddress;

	// Adding the instruction to the corresponding DRRA cell
	if (instInsertLocation_ == -1)
		_drraCluster->getDRRACell(cellCoord_)->instructions().addInstruction(raccuInst, true);
	else if (instInsertLocation_ != -2)
	{
		_drraCluster->getDRRACell(cellCoord_)->instructions().insert(instInsertLocation_, raccuInst);
		
		// Update the resource sharing checkpoint
		if (_isResourceSharingRegion)
			_resSharingInstructionManager.incrementIndexCheckpoint(cellCoord_);
	}
	else // it needs a postponed insertion
	{
		_deferredRaccuInstructions.push_back(MappedRaccuInstruction(getLoopSignature(forStatement_, cellCoord_, false), raccuInst));
	}

	addInstructionToMap(raccuInst, statementNo_, loopValues_, refCoord_, cellCoord_);
}

// This method creates a REFI instruction.
BIR::RefiInstruction * BEngine::createRefiInstruction(int statementNo_, int twinStatementNo_, string unrolledStatementNo_, const string & variableName_,
													  BIR::BIREnumerations::AddressMode addressMode_, BIR::BIREnumerations::PortMode portMode_, int numberOfAddress_,
													  int stepValue_, int numberOfRepetition_, int repetitionOffset_, int reverse_bits_, bool is_reverse_bits_static_, bool isDimarchMode_,
													  bool isInResSharingRegion_, BIR::DPUInstruction * correspondingDpuInst_, const string & pureVariableName_)
{
	RefiInstruction * refiInst = CREATE_OBJECT_B(RefiInstruction);

	refiInst->statementNo = statementNo_;
	refiInst->twinStatementNo = twinStatementNo_;
	refiInst->variableName = variableName_;
	refiInst->pureVariableName = pureVariableName_;
	refiInst->unrolledStatementNo = unrolledStatementNo_;
	refiInst->addressMode = addressMode_;
	refiInst->portMode = portMode_;
	refiInst->portNo = -1;
	refiInst->initialDelay(0, true);
	refiInst->middleDelay(0, true);
	refiInst->repetitionDelay(0, true);
	refiInst->dependentTo = 0;
	refiInst->numberOfAddress(numberOfAddress_, true);
	refiInst->stepValue(stepValue_, true);
	refiInst->numberOfRepetition(numberOfRepetition_, true);
	refiInst->repetitionOffset = repetitionOffset_;
	refiInst->reverse_bits(reverse_bits_, is_reverse_bits_static_);
	refiInst->isDimarchMode = isDimarchMode_;
	refiInst->isInResSharingRegion = isInResSharingRegion_;
	refiInst->correspondingDpuInst = correspondingDpuInst_;
	refiInst->correspondingRefiTransferInst = 0;
	refiInst->bankNo = 0;

	return refiInst;
}

// This method creates a memory RFILE instruction and adds it to the corresponding DiMArch cell and also to the instruction map.
void BEngine::createRfileInstruction(VIR::SliceName * sliceName_, LoopValuesMap * loopValues_, VIR::ReferencePragma * regFilePragma_, int statementNo_,
									 string unrolledStatementNo_, vector <MappedInstruction> & mappedRefiInsts_, int posIndex_, bool isMemToRegTrans_)
{
	createInstructionsForAVariable(sliceName_, loopValues_, regFilePragma_, statementNo_, 
		unrolledStatementNo_, mappedRefiInsts_, 0, posIndex_, !isMemToRegTrans_, 1, -1, true);

	/* REMOVE:
	ContileCell * contileCell = _drraCluster->diMArch()->getContileCell(memoryCoord_.column);
	DRRACell * drraCell = _drraCluster->getDRRACell(regFileCoord_);

	RFILEInstruction * rfileInst = CREATE_OBJECT_B(RFILEInstruction);

	rfileInst->statementNo = statementNo_;
	rfileInst->unrolledStatementNo = unrolledStatementNo_;
	rfileInst->isRead = !isMemToRegTrans_;
	rfileInst->drraRow = regFileCoord_.row;
	rfileInst->initialDelay = 0;
	rfileInst->middleDelay = 0;
	rfileInst->repetitionDelay = 0;
	rfileInst->addressMode = amLinear;

	const AddressInfo & addressInfo = indexInfo_->addressInfo;

	// Subtracting 1 from the start address is because MATLAB indices are started from 1, however RegFile indexing is started from 0.
	int refiStartAddress = addressInfo.startAddress + regFileStartAddr_ - 1;

	for (auto& element: indexInfo_->unrollingMap())
		refiStartAddress += element.second->unrollingOffset * loopValues_->at(element.first);

	// numberOfAddress is one less than the total number of addresses
	const int totalAddressesNum = addressInfo.numberOfAddress + 1;

	if (refiStartAddress % cMemWordSplit != 0 || totalAddressesNum % cMemWordSplit != 0)
		LOG(FATAL) << ("createRfileInstruction: For memory transfer, variable slice should be a multiple of 16!");

	rfileInst->startAddress = refiStartAddress / cMemWordSplit;
	rfileInst->endAddress = rfileInst->startAddress + totalAddressesNum / cMemWordSplit - 1 + addressInfo.numberOfRepetitions;
	rfileInst->increment = addressInfo.repetitionOffset / cMemWordSplit;
	rfileInst->numberOfRepetition = 0;
	rfileInst->repetitionOffset = 0;
	// TODO: at the moment, the number of repetition is added to the end address and it works in cases of a memory instruction inside a loop.
	// TODO: It needs further investigations.
	//rfileInst->increment = addressInfo.increment;
	//rfileInst->numberOfRepetition = addressInfo.numberOfRepetitions;
	//rfileInst->repetitionOffset = addressInfo.repetitionOffset / cMemWordSplit;

	contileCell->instructions().addInstruction(rfileInst);

	addInstructionToMap(rfileInst, statementNo_, loopValues_, regFileCoord_, memoryCoord_);

	contileCell->incTotalInstructionsCount(2);
	_drraCluster->diMArch()->incTotalInstructionsCount(2);*/
}



// This method calculates a dynamic start address for REFI or SRAM instructions.
// It updates the primary value of the given startAddress_ argument, if it is going to be calculated dynamically.
// This method returns true if the start address should be calculated dynamically.
// If there is any non-zero offset in the indexInfo->unrollingMap() or indexInfo->addressInfo.is1ndLevelDynamic or is2ndLevelDynamic are true,
// the start address should be calculated dynamically.
// The calculation mechanism for the start address is as follows:
//  - A RACCU register is assigned to store the dynamic values of the start address (resultAddress).
//  - A RACCU instruction will be created to initialize the register with the initial value (refiStartAddress).
//  - For each non-zero offset a RACCU instruction is created to add an offset to the current value of the register
//    after each RACCU loop iteration.
//  - The initialization RACCU instruction should be added before the LOOP_HEADER instruction corresponding to the loop
//    with the highest degree with a non-zero offset in the map.
//  - The offset RACCU instructions should be added before all corresponding LOOP_TAIL instructions.
//  - Finally the startAddress field of the refiInst should be set to the dynamic calculation mode referring to the 
//    assigned RACCU register address.
bool InstrGenerator::calculateDynamicStartAddress(int & startAddress_, IndexInfo * indexInfo_, int statementNo_, Instruction * dependentInst_, LoopValuesMap * loopValues_,
										   const VIR::Coordinate & referenceCoord_, const VIR::Coordinate & regFileCoord_, const string & indexVariableName_, bool isForMemory_)
{
	int resultAddress = -1;
	int offset = 0;
	ForStatement * outerForStatement = 0;
	bool isStartAddressDynamic = false;
	int calculatedStartAddress = 0;

	int increment = indexInfo_->addressInfo.increment;
	int repetitionOffset = indexInfo_->addressInfo.repetitionOffset;

	if (isForMemory_)
	{
		increment /= cMemWordSplit;
		repetitionOffset /= cMemWordSplit;
		startAddress_ /= cMemWordSplit;
	}

	if (indexInfo_->addressInfo.is1stLevelDynamic)
	{
		ForStatement * firstLevelLoop = indexInfo_->addressInfo.firstLevelLoop;

		if (indexInfo_->isARangeExpression)
			increment = repetitionOffset;

		// Create a RACCU instruction for adding the offset to the RACCU register.
		// As the corresponding LOOP_TAIL instruction has not been created yet, so this instruction is added to _deferredRaccuInstructions for a postponed insertion.
		createRaccuInstruction(statementNo_, rmAdd, resultAddress, false, increment, true,
			resultAddress, regFileCoord_, referenceCoord_, loopValues_, dependentInst_, -2, firstLevelLoop);

		outerForStatement = firstLevelLoop;
		isStartAddressDynamic = true;

		if (indexInfo_->addressInfo.firstLevelLoop && indexInfo_->addressInfo.firstLevelLoop->isConstant())
			offset = indexInfo_->addressInfo.firstLevelLoop->repetition() * repetitionOffset;
		else if (indexInfo_->addressInfo.firstLevelLoop && !indexInfo_->addressInfo.firstLevelLoop->isConstant())
			LOG(FATAL) << ("calculateDynamicStartAddress: Internal error for dynamic loops!");
	}

	if (indexInfo_->addressInfo.is2ndLevelDynamic)
	{
		if (indexInfo_->addressInfo.firstLevelLoop && indexInfo_->addressInfo.firstLevelLoop->isConstant())
		{
			LOG(INFO) << ("calculateDynamicStartAddress: RECHECK THIS CASE!");
			repetitionOffset -= indexInfo_->addressInfo.firstLevelLoop->repetition() / (isForMemory_ ? cMemWordSplit : 1);
		}

		// Create a RACCU instruction for adding the offset to the RACCU register.
		// As the corresponding LOOP_TAIL instruction has not been created yet, so this instruction is added to _deferredRaccuInstructions for a postponed insertion.
		createRaccuInstruction(statementNo_, rmAdd, resultAddress, false, repetitionOffset, true,
			resultAddress, regFileCoord_, referenceCoord_, loopValues_, dependentInst_, -2, indexInfo_->addressInfo.secondLevelLoop);

		outerForStatement = indexInfo_->addressInfo.secondLevelLoop;
		isStartAddressDynamic = true;
	}

	// The unrollingMap is ordered from the lowest degree to the highest one.
	// The reason is that when calculating the actual offset for a loop level,
	// the lower offsets should be subtracted from the higher ones.
	for (auto& element: indexInfo_->unrollingMap())
	{
		if (element.second->unrollingOffset != 0)
		{
			// Find the outer for statement corresponding which is involved in the indices of the current variable.
			if (!outerForStatement || outerForStatement->degree() < element.first->degree())
				outerForStatement = element.first;

			int unrollingOffset =  element.second->unrollingOffset;

			if (isForMemory_)
			{
				if (unrollingOffset % cMemWordSplit != 0)
					LOG(FATAL) << ("calculateDynamicStartAddress: For memory transfer, variable slice should be a multiple of 16!");

				 unrollingOffset /= cMemWordSplit;
			}

			offset = unrollingOffset - offset;

			// Create a RACCU instruction for adding the offset to the RACCU register.
			// As the corresponding LOOP_TAIL instruction has not been created yet, so this instruction is added to _deferredRaccuInstructions for a postponed insertion.
			if (offset != 0)
				createRaccuInstruction(statementNo_, rmAdd, resultAddress, false, offset, true, resultAddress, regFileCoord_, referenceCoord_, loopValues_, dependentInst_, -2, element.first);

			offset *= element.first->repetition();

			isStartAddressDynamic = true;
		}
	}

	if (isStartAddressDynamic)
	{
		LoopHeaderInstructionMap::const_iterator iter;

		// Find the corresponding LoopHeaderInstruction in the regFileCoord cell and insert the following RACCU instruction before this loop instruction.
		iter = _loopHeaderInstructionMap.find(getLoopSignature(outerForStatement, regFileCoord_, true));

		if (iter == _loopHeaderInstructionMap.end())
			LOG(FATAL) << ("calculateDynamicStartAddress: Internal Error (cannot find loop header instruction)!");

		// Create a RACCU instruction for initializing the RACCU register with the start address.
		createRaccuInstruction(statementNo_, rmAdd, startAddress_, true, 0, true, resultAddress, regFileCoord_, referenceCoord_, loopValues_, 0, iter->second->index);

		startAddress_ = resultAddress;
	}

	if (indexInfo_->isARaccuVariable)
	{
		isStartAddressDynamic = true;

		// Slice name has only one expression and that expression is an identifier
		startAddress_ = _raccuVariablesAddressMap[getRaccuVariableSignature(indexVariableName_, regFileCoord_)];
	}

	return isStartAddressDynamic;
}



}
}
